# Containerization & Preview Experience Implementation Plan

## Overview: Dev-Production Parity with Live Preview

Transform the current proxy-based architecture to a fully containerized system that provides a Glitch-like preview experience while maintaining development-production parity.

## Current Architecture Analysis

**Current Site Types:**
- Static sites → direct file serving
- Static-build sites → serve from dist/build directories  
- Passthrough sites → proxy to running processes on different ports
- Dynamic sites → direct TypeScript module imports
- Built-in sites → admin/editor (non-containerized)

**Key Challenge:** Move from process-based to container-based orchestration while adding live preview functionality.

## Phase 1: Small Editor Improvements (Quick Wins - 2-3 hours) ⏳ IN PROGRESS

### 1.1 File Tree Enhancements
- **Add "+" button** for new file creation in file tree
- **Right-click context menu** for file operations
- **Filename in URL** for refresh persistence (`/editor/site-name?file=path/to/file.js`)

### 1.2 URL State Management
- Update browser URL when files are opened
- Handle page refresh to reopen last file
- Maintain editor state across navigation

## Phase 2: Container Architecture Foundation (1-2 weeks)

### 2.1 Railpack Integration Strategy
**Decision:** Use Railpack for automatic containerization
- **Static HTML sites**: Simple nginx container
- **Node.js apps**: Node 22 runtime container  
- **Astro sites**: Build + serve container
- **Next.js apps**: Production build container
- **Built-in sites**: Remain non-containerized (admin/editor)

### 2.2 Container Management System
**New Service**: `ContainerManager`
- **Container Registry**: Track running containers per site
- **Port Management**: Dynamic port allocation for containers
- **Health Monitoring**: Container health checks and restarts
- **Resource Limits**: Memory/CPU limits per container

### 2.3 Development-Production Parity
**Strategy**: Same containers in both environments
- **Development**: Containers with volume mounts for live reload
- **Production**: Immutable containers with baked-in code
- **Shared Dockerfiles**: Generated by Railpack for consistency

## Phase 3: Preview Experience Architecture (2-3 weeks)

### 3.1 Preview Domain Strategy
**URL Structure:**
- **Main site**: `https://site-name.domain`
- **Preview site**: `https://preview-site-name.domain`
- **Special case**: Home site preview at `https://preview.domain`

### 3.2 Preview Container Lifecycle
**On File Save (Ctrl+S):**
1. **Immediate Save**: Update file in editor
2. **Trigger Rebuild**: Signal preview container to rebuild
3. **Hot Swap**: Replace running preview container
4. **Notify Editor**: Send success/error status back

### 3.3 Editor-Preview Communication
**Architecture Decision**: iframe + postMessage
- **Editor Side**: Preview iframe embedded in editor
- **Preview Side**: postMessage API for status updates
- **Communication Protocol**:
  ```typescript
  // Editor → Preview
  { type: 'RELOAD', timestamp: Date.now() }
  { type: 'FILE_UPDATED', file: 'path/to/file.js' }
  
  // Preview → Editor  
  { type: 'LOADED', status: 'ready' }
  { type: 'ERROR', error: 'build failed', details: '...' }
  ```

### 3.4 Preview Container Types
**Development Containers** (with live reload):
- **Static sites**: nginx + file watcher
- **Node apps**: nodemon + hot reload
- **Build sites**: watch mode + serve

**Special Handling**:
- **Pure HTML**: Instant reload (no build step)
- **TypeScript/Build sites**: Incremental builds only

## Phase 4: Technical Implementation Details

### 4.1 Container Orchestration
**Docker Compose Alternative**: Custom lightweight orchestrator
```typescript
class SiteContainer {
  name: string;
  type: 'preview' | 'production'; 
  port: number;
  status: 'building' | 'running' | 'failed';
  
  async build(): Promise<void>
  async start(): Promise<void>
  async stop(): Promise<void>
  async restart(): Promise<void>
}
```

### 4.2 File System Integration
**Volume Mounts for Development**:
- **Read-only**: Site source files
- **Read-write**: Build outputs, logs
- **Shared**: Editor temp files for hot reload

### 4.3 Editor UI Enhancements
**Three-Panel Layout**:
- **Left**: File tree (25%)
- **Center**: Code editor (50%) 
- **Right**: Live preview iframe (25%)

**Preview Panel Features**:
- **Responsive toggle**: Mobile/tablet/desktop views
- **Reload indicator**: Visual feedback during rebuilds
- **Error overlay**: Build errors displayed in preview
- **Console output**: Stream container logs to editor

### 4.4 Performance Optimization
**Container Pooling**:
- **Base images**: Pre-warmed for common frameworks
- **Incremental builds**: Only rebuild changed dependencies
- **Resource sharing**: Shared node_modules volumes

## Phase 5: UX/UI Design Considerations

### 5.1 Visual Design Language
**"HTML is Cool" Aesthetic**:
- **Pastel terminal colors**: Maintain current MonaspaceNeon theme
- **Subtle animations**: Container status transitions
- **Friendly error messages**: Clear, actionable feedback
- **Progress indicators**: Build/reload status

### 5.2 Preview Experience
**Glitch-like Feel**:
- **Instant visual feedback** on save
- **Split-screen editing**: Code + preview side-by-side
- **Error states**: Friendly build failure messages
- **Loading states**: Preview rebuilding indicators

### 5.3 Mobile Responsive Considerations
- **Collapsible panels**: Stack on mobile
- **Touch-friendly**: File tree and buttons
- **Preview modes**: Full-screen preview on mobile

## Phase 6: Integration & Migration

### 6.1 Backward Compatibility
**Migration Strategy**:
- **Phase rollout**: Container support per site type
- **Fallback mode**: Keep current proxy system during transition
- **User choice**: Opt-in containerization initially

### 6.2 Admin Panel Integration
**Container Management UI**:
- **Container status** dashboard in admin
- **Resource usage** monitoring
- **Container logs** viewing
- **Manual restart** capabilities

## Technical Risks & Mitigation

### 6.1 Performance Risks
- **Container startup time**: Mitigated by pre-warmed images
- **Resource usage**: Mitigated by limits and monitoring
- **Build time**: Mitigated by incremental builds

### 6.2 Complexity Risks
- **Container orchestration**: Start simple, avoid Docker Compose
- **Preview sync**: Use proven postMessage patterns
- **File watching**: Leverage existing file system events

## Success Metrics

### 6.1 Performance Targets
- **Container startup**: < 3 seconds for cached images
- **Preview update**: < 2 seconds for simple changes
- **Editor responsiveness**: No lag during file operations

### 6.2 User Experience Goals
- **Seamless preview**: Updates feel instant
- **Clear feedback**: Users understand what's happening
- **Error recovery**: Easy to fix and retry failed builds

## Implementation Priority

### **Phase 1** (Immediate - 2-3 hours):
- File tree improvements
- Filename in URL

### **Phase 2** (Foundation - 1-2 weeks):
- Railpack integration
- Basic container management

### **Phase 3** (Preview - 2-3 weeks):
- Preview domains and containers
- Editor-preview communication

### **Phases 4-6** (Polish - 2-3 weeks):
- UI enhancements
- Performance optimization
- Admin integration

**Total Estimate: 6-8 weeks for full implementation**

---

## Decision Log

### 2025-08-25: Initial Architecture Decisions
- **Container Tool**: Railpack for zero-config containerization
- **Preview Strategy**: iframe + postMessage for editor-preview communication
- **Domain Pattern**: preview-site-name.domain for preview URLs
- **Container Scope**: All sites containerized except built-in admin/editor
- **Development Parity**: Same containers in dev and prod with volume mounts

### Next Review: After Phase 1 completion
- Assess file tree UX improvements
- Validate URL state management approach
- Plan Phase 2 Railpack integration strategy