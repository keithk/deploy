import { join } from 'path';
import { existsSync, readFileSync, writeFileSync } from 'fs';
import { detectPackageManager } from '@keithk/deploy-core/src/utils/packageManager';

interface MiseConfig {
  tools?: Record<string, string>;
  tasks?: Record<string, {
    run: string;
    description?: string;
    env?: Record<string, string>;
  }>;
  env?: Record<string, string>;
}

/**
 * Generates a mise configuration for a project based on its structure
 */
function generateMiseConfig(sitePath: string): MiseConfig {
  const config: MiseConfig = {
    tools: {},
    tasks: {},
    env: {}
  };

  try {
    // Check for package.json to understand the project
    const packageJsonPath = join(sitePath, 'package.json');
    if (existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
      
      // Detect runtime and versions
      const currentPackageManager = detectPackageManager(sitePath);
      
      // Set appropriate tools based on lock files and dependencies
      if (currentPackageManager === 'bun' || packageJson.dependencies?.['bun-types']) {
        config.tools!.bun = '1.1.30';
        config.tools!.node = '22'; // Bun often needs Node for compatibility
      } else {
        config.tools!.node = '22';
      }
      
      // Generate tasks based on package.json scripts
      if (packageJson.scripts) {
        Object.entries(packageJson.scripts).forEach(([scriptName, command]) => {
          const cmd = command as string;
          
          // Common task mappings
          switch (scriptName) {
            case 'dev':
              config.tasks![scriptName] = {
                run: cmd.includes('--host') ? cmd : `${cmd} --host 0.0.0.0`,
                description: 'Start development server with hot reload',
                env: { NODE_ENV: 'development' }
              };
              break;
            case 'start':
              config.tasks![scriptName] = {
                run: cmd.includes('--host') ? cmd : `${cmd} --host 0.0.0.0`,
                description: 'Start production server',
                env: { NODE_ENV: 'production' }
              };
              break;
            case 'build':
              config.tasks![scriptName] = {
                run: cmd,
                description: 'Build the application'
              };
              break;
            case 'test':
              config.tasks![scriptName] = {
                run: cmd,
                description: 'Run tests'
              };
              break;
            default:
              // Include other scripts as-is
              config.tasks![scriptName] = {
                run: cmd,
                description: `Run ${scriptName} script`
              };
          }
        });
      }
      
      // Add default tasks if not present
      if (!config.tasks!.install) {
        const installCmd = currentPackageManager === 'bun' ? 'bun install' : 
                          currentPackageManager === 'yarn' ? 'yarn install' :
                          currentPackageManager === 'pnpm' ? 'pnpm install' : 'npm install';
        
        config.tasks!.install = {
          run: installCmd,
          description: 'Install dependencies'
        };
      }
      
      // Set common environment variables
      config.env = {
        PORT: '3000',
        HOST: '0.0.0.0'
      };
      
      // Framework-specific configurations
      if (packageJson.dependencies?.vite || packageJson.devDependencies?.vite) {
        config.env.VITE_HOST = '0.0.0.0';
        config.env.VITE_PORT = '3000';
      }
    }
  } catch (err) {
    console.warn(`Warning: Failed to parse project structure: ${err}`);
  }

  return config;
}

/**
 * Converts a mise config object to TOML format
 */
function configToToml(config: MiseConfig): string {
  let toml = '# Mise configuration generated by Deploy\n';
  
  if (config.tools && Object.keys(config.tools).length > 0) {
    toml += '\n[tools]\n';
    Object.entries(config.tools).forEach(([tool, version]) => {
      toml += `${tool} = "${version}"\n`;
    });
  }
  
  if (config.tasks && Object.keys(config.tasks).length > 0) {
    Object.entries(config.tasks).forEach(([taskName, task]) => {
      toml += `\n[tasks.${taskName}]\n`;
      toml += `run = "${task.run}"\n`;
      if (task.description) {
        toml += `description = "${task.description}"\n`;
      }
      if (task.env && Object.keys(task.env).length > 0) {
        toml += 'env = { ';
        const envEntries = Object.entries(task.env).map(([key, value]) => `${key} = "${value}"`);
        toml += envEntries.join(', ');
        toml += ' }\n';
      }
    });
  }
  
  if (config.env && Object.keys(config.env).length > 0) {
    toml += '\n[env]\n';
    Object.entries(config.env).forEach(([key, value]) => {
      toml += `${key} = "${value}"\n`;
    });
  }
  
  return toml;
}

export async function migrateToMise(siteName: string, sitesDir: string = './sites'): Promise<void> {
  const sitePath = join(sitesDir, siteName);
  
  if (!existsSync(sitePath)) {
    console.error(`‚ùå Site '${siteName}' not found at ${sitePath}`);
    process.exit(1);
  }
  
  const miseConfigPath = join(sitePath, '.mise.toml');
  
  if (existsSync(miseConfigPath)) {
    console.log(`‚ö†Ô∏è  Site '${siteName}' already has a .mise.toml file`);
    console.log('Do you want to overwrite it? (y/N)');
    
    // For now, skip overwriting
    console.log('Skipping overwrite. Use --force to overwrite existing configs.');
    return;
  }
  
  console.log(`üîß Generating mise configuration for site: ${siteName}`);
  
  const config = generateMiseConfig(sitePath);
  const tomlContent = configToToml(config);
  
  writeFileSync(miseConfigPath, tomlContent, 'utf8');
  
  console.log(`‚úÖ Created .mise.toml for ${siteName}`);
  console.log('\nüìã Generated configuration:');
  console.log(tomlContent);
  console.log('\nüöÄ Next steps:');
  console.log('1. Review and customize the generated .mise.toml file');
  console.log('2. Restart any running containers for this site');
  console.log('3. Test the site with: cd sites/' + siteName + ' && mise run dev');
}

export async function listMiseSites(sitesDir: string = './sites'): Promise<void> {
  const { readdirSync } = await import('fs');
  
  try {
    const entries = readdirSync(sitesDir, { withFileTypes: true });
    const sites = entries
      .filter(entry => entry.isDirectory())
      .filter(entry => !['logs', '.git', '.deploy', 'admin', 'editor'].includes(entry.name))
      .map(entry => ({
        name: entry.name,
        path: join(sitesDir, entry.name),
        hasMise: existsSync(join(sitesDir, entry.name, '.mise.toml'))
      }));
    
    console.log('\nüìã Sites status:');
    sites.forEach(site => {
      const status = site.hasMise ? '‚úÖ Mise' : 'üì¶ Traditional';
      console.log(`  ${status} ${site.name}`);
    });
    
    const miseCount = sites.filter(s => s.hasMise).length;
    const totalCount = sites.length;
    
    console.log(`\nüìä Summary: ${miseCount}/${totalCount} sites using mise`);
    
    if (miseCount < totalCount) {
      console.log('\nüîß To migrate remaining sites:');
      sites.filter(s => !s.hasMise).forEach(site => {
        console.log(`  deploy mise migrate ${site.name}`);
      });
    }
  } catch (err) {
    console.error(`‚ùå Failed to list sites: ${err}`);
  }
}