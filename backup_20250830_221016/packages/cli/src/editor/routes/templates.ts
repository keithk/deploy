import { Hono } from 'hono';
import { join, resolve } from 'path';
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import { Database } from '@keithk/deploy-core/src/database/database';
import { requireAuth } from './auth';
import { spawn } from 'child_process';
import { promisify } from 'util';
// Import the mise functionality (path may need adjustment)
async function generateMiseConfigForSite(siteName: string, sitePath: string) {
  try {
    // This would typically call the mise migration functionality
    // For now, we'll create a basic .mise.toml file
    const miseConfigPath = join(sitePath, '.mise.toml');
    const basicConfig = `# Mise configuration generated by Deploy
[tools]
node = "22"

[tasks.dev]
run = "npm run dev"
description = "Start development server"

[tasks.build]
run = "npm run build"
description = "Build the application"

[tasks.install]
run = "npm install"
description = "Install dependencies"

[env]
NODE_ENV = "development"
`;
    writeFileSync(miseConfigPath, basicConfig, 'utf8');
    console.log(`Generated basic mise config for ${siteName}`);
  } catch (err) {
    console.warn(`Failed to generate mise config for ${siteName}:`, err);
  }
}

const templatesRoutes = new Hono();

// Apply authentication to all template routes
templatesRoutes.use('*', requireAuth);

interface SiteTemplate {
  id: string;
  name: string;
  description: string;
  category: 'frontend' | 'fullstack' | 'api' | 'static';
  command: string;
  args: string[];
  tags: string[];
  requirements: string[];
  preview?: string;
}

// Predefined site templates
const SITE_TEMPLATES: SiteTemplate[] = [
  // Frontend Frameworks
  {
    id: 'vite-react',
    name: 'React + Vite',
    description: 'Modern React app with Vite build tool and hot reload',
    category: 'frontend',
    command: 'npm',
    args: ['create', 'vite@latest', '{siteName}', '--template', 'react'],
    tags: ['react', 'vite', 'javascript', 'spa'],
    requirements: ['node >= 18']
  },
  {
    id: 'vite-react-ts',
    name: 'React + TypeScript + Vite',
    description: 'React app with TypeScript and Vite for type-safe development',
    category: 'frontend',
    command: 'npm',
    args: ['create', 'vite@latest', '{siteName}', '--template', 'react-ts'],
    tags: ['react', 'typescript', 'vite', 'spa'],
    requirements: ['node >= 18']
  },
  {
    id: 'next-app',
    name: 'Next.js App Router',
    description: 'Full-stack React framework with App Router and TypeScript',
    category: 'fullstack',
    command: 'npx',
    args: ['create-next-app@latest', '{siteName}', '--typescript', '--tailwind', '--eslint', '--app'],
    tags: ['next.js', 'react', 'typescript', 'tailwind', 'ssr'],
    requirements: ['node >= 18']
  },
  {
    id: 'astro-blog',
    name: 'Astro Blog',
    description: 'Fast static site generator with content collections',
    category: 'static',
    command: 'npm',
    args: ['create', 'astro@latest', '{siteName}', '--template', 'blog'],
    tags: ['astro', 'blog', 'static', 'markdown'],
    requirements: ['node >= 18']
  },
  {
    id: 'svelte-kit',
    name: 'SvelteKit',
    description: 'Full-stack framework powered by Svelte with TypeScript',
    category: 'fullstack',
    command: 'npm',
    args: ['create', 'svelte@latest', '{siteName}'],
    tags: ['svelte', 'sveltekit', 'typescript', 'ssr'],
    requirements: ['node >= 16']
  },
  {
    id: 'vue-vite',
    name: 'Vue 3 + Vite',
    description: 'Vue 3 app with Vite and Composition API',
    category: 'frontend',
    command: 'npm',
    args: ['create', 'vue@latest', '{siteName}'],
    tags: ['vue', 'vite', 'composition-api', 'spa'],
    requirements: ['node >= 16']
  },
  
  // Backend/API Templates
  {
    id: 'express-api',
    name: 'Express API',
    description: 'RESTful API server with Express and TypeScript',
    category: 'api',
    command: 'npx',
    args: ['express-generator-typescript', '{siteName}'],
    tags: ['express', 'typescript', 'api', 'rest'],
    requirements: ['node >= 16']
  },
  {
    id: 'fastify-api',
    name: 'Fastify API',
    description: 'High-performance API server with Fastify and TypeScript',
    category: 'api',
    command: 'npm',
    args: ['create', 'fastify@latest', '{siteName}'],
    tags: ['fastify', 'typescript', 'api', 'performance'],
    requirements: ['node >= 18']
  },
  
  // Static Site Generators
  {
    id: 'hugo-site',
    name: 'Hugo Static Site',
    description: 'Fast static site generator built with Go',
    category: 'static',
    command: 'hugo',
    args: ['new', 'site', '{siteName}'],
    tags: ['hugo', 'go', 'static', 'blog'],
    requirements: ['hugo >= 0.100']
  },
  
  // Full-Stack Templates
  {
    id: 'remix-app',
    name: 'Remix',
    description: 'Full-stack web framework focused on web standards',
    category: 'fullstack',
    command: 'npx',
    args: ['create-remix@latest', '{siteName}'],
    tags: ['remix', 'react', 'typescript', 'ssr'],
    requirements: ['node >= 18']
  },
  
  // Bun Templates
  {
    id: 'bun-app',
    name: 'Bun + Hono API',
    description: 'Ultra-fast API server with Bun runtime and Hono framework',
    category: 'api',
    command: 'bun',
    args: ['create', 'hono', '{siteName}'],
    tags: ['bun', 'hono', 'typescript', 'api', 'performance'],
    requirements: ['bun >= 1.0']
  }
];

/**
 * Execute command and return result
 */
async function execCommand(command: string, args: string[], cwd: string): Promise<{ stdout: string; stderr: string; exitCode: number }> {
  return new Promise((resolve) => {
    const child = spawn(command, args, {
      cwd,
      stdio: ['pipe', 'pipe', 'pipe'],
      env: { ...process.env }
    });

    let stdout = '';
    let stderr = '';

    child.stdout?.on('data', (data) => {
      stdout += data.toString();
    });

    child.stderr?.on('data', (data) => {
      stderr += data.toString();
    });

    child.on('close', (exitCode) => {
      resolve({ stdout, stderr, exitCode: exitCode || 0 });
    });

    // Timeout after 5 minutes for site creation
    setTimeout(() => {
      child.kill('SIGTERM');
      resolve({ stdout, stderr: stderr + '\nCommand timed out after 5 minutes', exitCode: 1 });
    }, 300000);
  });
}

// Get available site templates
templatesRoutes.get('/templates', async (c) => {
  const user = c.get('user');
  
  try {
    // Check user's site count for display purposes
    const db = Database.getInstance();
    const userSites = db.query<{ count: number }>(
      `SELECT COUNT(*) as count FROM sites WHERE user_id = ?`,
      [user.id]
    );
    
    const sitesUsed = userSites[0].count;
    const sitesLimit = user.max_sites;
    const canCreateSite = sitesUsed < sitesLimit;
    
    return c.json({
      success: true,
      data: {
        templates: SITE_TEMPLATES,
        userInfo: {
          sitesUsed,
          sitesLimit,
          canCreateSite
        }
      }
    });
    
  } catch (error) {
    console.error('Error fetching templates:', error);
    return c.json({ success: false, error: 'Failed to fetch templates' });
  }
});

// Create new site from template
templatesRoutes.post('/templates/create', async (c) => {
  const user = c.get('user');
  
  try {
    const { templateId, siteName, options = {} } = await c.req.json();
    
    if (!templateId || !siteName) {
      return c.json({ success: false, error: 'Template ID and site name are required' });
    }
    
    // Validate site name (alphanumeric and hyphens only)
    if (!/^[a-zA-Z0-9-]+$/.test(siteName)) {
      return c.json({ success: false, error: 'Site name can only contain letters, numbers, and hyphens' });
    }
    
    // Check user's site limit
    const db = Database.getInstance();
    const userSites = db.query<{ count: number }>(
      `SELECT COUNT(*) as count FROM sites WHERE user_id = ?`,
      [user.id]
    );
    
    if (userSites[0].count >= user.max_sites) {
      return c.json({ success: false, error: 'Site limit reached' });
    }
    
    // Check if site already exists
    const existingSites = db.query<{ count: number }>(
      `SELECT COUNT(*) as count FROM sites WHERE name = ?`,
      [siteName]
    );
    
    if (existingSites[0].count > 0) {
      return c.json({ success: false, error: 'Site name already exists' });
    }
    
    // Find template
    const template = SITE_TEMPLATES.find(t => t.id === templateId);
    if (!template) {
      return c.json({ success: false, error: 'Template not found' });
    }
    
    // Create site directory
    const rootDir = process.env.ROOT_DIR || './sites';
    const sitePath = join(rootDir, siteName);
    
    if (existsSync(sitePath)) {
      return c.json({ success: false, error: 'Site directory already exists' });
    }
    
    // Ensure root directory exists
    if (!existsSync(rootDir)) {
      mkdirSync(rootDir, { recursive: true });
    }
    
    // Replace placeholder in command args
    const processedArgs = template.args.map(arg => 
      arg.replace('{siteName}', siteName)
    );
    
    // Execute template creation command
    const result = await execCommand(template.command, processedArgs, rootDir);
    
    if (result.exitCode !== 0) {
      return c.json({ 
        success: false, 
        error: `Failed to create site from template: ${result.stderr}`,
        output: result.stdout
      });
    }
    
    // Verify site directory was created
    if (!existsSync(sitePath)) {
      return c.json({ 
        success: false, 
        error: 'Site directory was not created by template command'
      });
    }
    
    // Generate mise configuration for the new site
    try {
      await generateMiseConfigForSite(siteName, sitePath);
    } catch (err) {
      console.warn(`Failed to generate mise config for ${siteName}:`, err);
      // Continue even if mise generation fails
    }
    
    // Create database entry
    const siteUrl = `https://${siteName}.${process.env.PROJECT_DOMAIN || 'dev.deploy'}`;
    db.run(
      `INSERT INTO sites (user_id, name, domain, path, status, created_at, last_edited)
       VALUES (?, ?, ?, ?, 'stopped', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
      [user.id, siteName, siteUrl, sitePath]
    );
    
    return c.json({
      success: true,
      data: {
        siteName,
        sitePath,
        siteUrl,
        template: template.name
      },
      message: `Site '${siteName}' created successfully from ${template.name} template`,
      output: result.stdout
    });
    
  } catch (error) {
    console.error('Error creating site from template:', error);
    return c.json({ success: false, error: 'Failed to create site from template' });
  }
});

// Get template details and preview
templatesRoutes.get('/templates/:templateId', async (c) => {
  const templateId = c.req.param('templateId');
  
  try {
    const template = SITE_TEMPLATES.find(t => t.id === templateId);
    
    if (!template) {
      return c.json({ success: false, error: 'Template not found' });
    }
    
    // Add additional details for the specific template
    const templateDetails = {
      ...template,
      commandPreview: `${template.command} ${template.args.join(' ')}`.replace('{siteName}', '<site-name>'),
      estimatedTime: getEstimatedCreationTime(template),
      fileStructure: getTemplateFileStructure(template)
    };
    
    return c.json({
      success: true,
      data: templateDetails
    });
    
  } catch (error) {
    console.error('Error fetching template details:', error);
    return c.json({ success: false, error: 'Failed to fetch template details' });
  }
});

// Check if required tools are available
templatesRoutes.post('/templates/check-requirements', async (c) => {
  try {
    const { templateId } = await c.req.json();
    
    const template = SITE_TEMPLATES.find(t => t.id === templateId);
    if (!template) {
      return c.json({ success: false, error: 'Template not found' });
    }
    
    const requirements = template.requirements;
    const checkResults = await Promise.all(
      requirements.map(async (req) => {
        const [tool, version] = req.split(' >= ');
        return checkToolVersion(tool, version);
      })
    );
    
    const allRequirementsMet = checkResults.every(r => r.available);
    
    return c.json({
      success: true,
      data: {
        requirements: checkResults,
        allRequirementsMet,
        canProceed: allRequirementsMet
      }
    });
    
  } catch (error) {
    console.error('Error checking template requirements:', error);
    return c.json({ success: false, error: 'Failed to check requirements' });
  }
});

/**
 * Check if a tool is available and meets version requirements
 */
async function checkToolVersion(tool: string, requiredVersion?: string): Promise<{
  tool: string;
  available: boolean;
  currentVersion?: string;
  requiredVersion?: string;
  meetsRequirement: boolean;
}> {
  try {
    let versionCommand;
    switch (tool) {
      case 'node':
        versionCommand = ['node', ['--version']];
        break;
      case 'bun':
        versionCommand = ['bun', ['--version']];
        break;
      case 'hugo':
        versionCommand = ['hugo', ['version']];
        break;
      default:
        versionCommand = [tool, ['--version']];
    }
    
    const result = await execCommand(versionCommand[0], versionCommand[1], process.cwd());
    
    if (result.exitCode === 0) {
      const versionOutput = result.stdout.trim();
      const currentVersion = extractVersionNumber(versionOutput);
      
      let meetsRequirement = true;
      if (requiredVersion) {
        meetsRequirement = compareVersions(currentVersion, requiredVersion) >= 0;
      }
      
      return {
        tool,
        available: true,
        currentVersion,
        requiredVersion,
        meetsRequirement
      };
    } else {
      return {
        tool,
        available: false,
        requiredVersion,
        meetsRequirement: false
      };
    }
  } catch (error) {
    return {
      tool,
      available: false,
      requiredVersion,
      meetsRequirement: false
    };
  }
}

/**
 * Extract version number from version command output
 */
function extractVersionNumber(output: string): string {
  const versionMatch = output.match(/(\d+\.\d+\.\d+)/);
  return versionMatch ? versionMatch[1] : output.replace(/[^\d.]/g, '');
}

/**
 * Compare two version strings (returns -1, 0, or 1)
 */
function compareVersions(version1: string, version2: string): number {
  const v1Parts = version1.split('.').map(Number);
  const v2Parts = version2.split('.').map(Number);
  
  for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
    const v1Part = v1Parts[i] || 0;
    const v2Part = v2Parts[i] || 0;
    
    if (v1Part < v2Part) return -1;
    if (v1Part > v2Part) return 1;
  }
  
  return 0;
}

/**
 * Get estimated creation time for template
 */
function getEstimatedCreationTime(template: SiteTemplate): string {
  const timeMap: Record<string, string> = {
    'vite-react': '30-60 seconds',
    'vite-react-ts': '30-60 seconds',
    'next-app': '2-3 minutes',
    'astro-blog': '45-90 seconds',
    'svelte-kit': '1-2 minutes',
    'vue-vite': '30-60 seconds',
    'express-api': '1-2 minutes',
    'fastify-api': '45-90 seconds',
    'hugo-site': '10-30 seconds',
    'remix-app': '1-2 minutes',
    'bun-app': '20-45 seconds'
  };
  
  return timeMap[template.id] || '1-2 minutes';
}

/**
 * Get expected file structure for template
 */
function getTemplateFileStructure(template: SiteTemplate): string[] {
  const structureMap: Record<string, string[]> = {
    'vite-react': ['src/', 'src/App.jsx', 'src/main.jsx', 'index.html', 'package.json', 'vite.config.js'],
    'vite-react-ts': ['src/', 'src/App.tsx', 'src/main.tsx', 'index.html', 'package.json', 'vite.config.ts'],
    'next-app': ['app/', 'app/page.tsx', 'app/layout.tsx', 'package.json', 'next.config.js', 'tailwind.config.js'],
    'astro-blog': ['src/', 'src/pages/', 'src/content/', 'astro.config.mjs', 'package.json'],
    'svelte-kit': ['src/', 'src/routes/', 'src/app.html', 'package.json', 'svelte.config.js'],
    'vue-vite': ['src/', 'src/App.vue', 'src/main.js', 'index.html', 'package.json', 'vite.config.js'],
    'express-api': ['src/', 'src/server.ts', 'src/routes/', 'package.json', 'tsconfig.json'],
    'fastify-api': ['src/', 'src/app.ts', 'src/plugins/', 'package.json', 'tsconfig.json'],
    'hugo-site': ['content/', 'themes/', 'config.toml', 'layouts/'],
    'remix-app': ['app/', 'app/root.tsx', 'app/routes/', 'package.json', 'remix.config.js'],
    'bun-app': ['src/', 'src/index.ts', 'package.json', 'tsconfig.json']
  };
  
  return structureMap[template.id] || ['package.json', 'src/', 'README.md'];
}

export { templatesRoutes };